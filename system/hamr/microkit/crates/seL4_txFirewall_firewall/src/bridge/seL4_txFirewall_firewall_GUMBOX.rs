// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

pub fn two_bytes_to_u16(
  byte0: u8,
  byte1: u8) -> u16
{
  ((byte0) as u16) * 256u16 + ((byte1) as u16)
}

pub fn frame_is_wellformed_eth2(aframe: SW::RawEthernetMessage) -> bool
{
  valid_frame_ethertype(aframe) & valid_frame_dst_addr(aframe)
}

pub fn valid_frame_ethertype(aframe: SW::RawEthernetMessage) -> bool
{
  frame_has_ipv4(aframe) |
    (frame_has_arp(aframe) | frame_has_ipv6(aframe))
}

pub fn valid_frame_dst_addr(aframe: SW::RawEthernetMessage) -> bool
{
  !((aframe[0] == 0u8) &
    ((aframe[1] == 0u8) &
      ((aframe[2] == 0u8) &
        ((aframe[3] == 0u8) &
          ((aframe[4] == 0u8) &
            (aframe[5] == 0u8))))))
}

pub fn frame_has_ipv4(aframe: SW::RawEthernetMessage) -> bool
{
  (aframe[12] == 8u8) &
    (aframe[13] == 0u8)
}

pub fn frame_has_ipv6(aframe: SW::RawEthernetMessage) -> bool
{
  (aframe[12] == 134u8) &
    (aframe[13] == 221u8)
}

pub fn frame_has_arp(aframe: SW::RawEthernetMessage) -> bool
{
  (aframe[12] == 8u8) &
    (aframe[13] == 6u8)
}

pub fn arp_has_ipv4(aframe: SW::RawEthernetMessage) -> bool
{
  (aframe[16] == 8u8) &
    (aframe[17] == 0u8)
}

pub fn arp_has_ipv6(aframe: SW::RawEthernetMessage) -> bool
{
  (aframe[16] == 134u8) &
    (aframe[17] == 221u8)
}

pub fn valid_arp_ptype(aframe: SW::RawEthernetMessage) -> bool
{
  arp_has_ipv4(aframe) | arp_has_ipv6(aframe)
}

pub fn valid_arp_op(aframe: SW::RawEthernetMessage) -> bool
{
  (aframe[20] == 0u8) &
    ((aframe[21] == 1u8) |
      (aframe[21] == 2u8))
}

pub fn valid_arp_htype(aframe: SW::RawEthernetMessage) -> bool
{
  (aframe[14] == 0u8) &
    (aframe[15] == 1u8)
}

pub fn wellformed_arp_frame(aframe: SW::RawEthernetMessage) -> bool
{
  valid_arp_op(aframe) &
    (valid_arp_htype(aframe) & valid_arp_ptype(aframe))
}

pub fn ipv4_length(aframe: SW::RawEthernetMessage) -> u16
{
  two_bytes_to_u16(aframe[16], aframe[17])
}

pub fn valid_ipv4_length(aframe: SW::RawEthernetMessage) -> bool
{
  ipv4_length(aframe) <= 9000u16
}

pub fn valid_ipv4_protocol(aframe: SW::RawEthernetMessage) -> bool
{
  (aframe[23] == 0u8) |
    ((aframe[23] == 1u8) |
      ((aframe[23] == 2u8) |
        ((aframe[23] == 6u8) |
          ((aframe[23] == 17u8) |
            ((aframe[23] == 43u8) |
              ((aframe[23] == 44u8) |
                ((aframe[23] == 58u8) |
                  ((aframe[23] == 59u8) |
                    (aframe[23] == 60u8)))))))))
}

pub fn valid_ipv4_vers_ihl(aframe: SW::RawEthernetMessage) -> bool
{
  aframe[14] == 69u8
}

pub fn wellformed_ipv4_frame(aframe: SW::RawEthernetMessage) -> bool
{
  valid_ipv4_protocol(aframe) &
    (valid_ipv4_length(aframe) & valid_ipv4_vers_ihl(aframe))
}

pub fn valid_ipv6(aframe: SW::RawEthernetMessage) -> bool
{
  frame_is_wellformed_eth2(aframe) & frame_has_ipv6(aframe)
}

pub fn valid_arp(aframe: SW::RawEthernetMessage) -> bool
{
  frame_is_wellformed_eth2(aframe) &
    (frame_has_arp(aframe) & wellformed_arp_frame(aframe))
}

pub fn valid_ipv4(aframe: SW::RawEthernetMessage) -> bool
{
  frame_is_wellformed_eth2(aframe) &
    (frame_has_ipv4(aframe) & wellformed_ipv4_frame(aframe))
}

pub fn valid_output_arp_size(output: SW::SizedEthernetMessage) -> bool
{
  output.sz == 64u16
}

pub fn valid_output_ipv4_size(
  input: SW::RawEthernetMessage,
  output: SW::SizedEthernetMessage) -> bool
{
  output.sz == ipv4_length(input) + 14u16
}

pub fn allow_outbound_frame(aframe: SW::RawEthernetMessage) -> bool
{
  valid_arp(aframe) | valid_ipv4(aframe)
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_07_tx0_can_send_valid_arp
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_spec_hlr_07_tx0_can_send_valid_arp_guarantee(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn0.is_some() & valid_arp(api_EthernetFramesTxIn0.unwrap()),
    api_EthernetFramesTxOut0.is_some() &
      ((api_EthernetFramesTxIn0.unwrap() == api_EthernetFramesTxOut0.unwrap().amessage) &
        valid_output_arp_size(api_EthernetFramesTxOut0.unwrap())))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_12_tx0_can_send_valid_ipv4
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_spec_hlr_12_tx0_can_send_valid_ipv4_guarantee(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn0.is_some() & valid_ipv4(api_EthernetFramesTxIn0.unwrap()),
    api_EthernetFramesTxOut0.is_some() &
      ((api_EthernetFramesTxIn0.unwrap() == api_EthernetFramesTxOut0.unwrap().amessage) &
        valid_output_ipv4_size(api_EthernetFramesTxIn0.unwrap(), api_EthernetFramesTxOut0.unwrap())))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_14_tx0_disallow
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_spec_hlr_14_tx0_disallow_guarantee(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn0.is_some() & !(allow_outbound_frame(api_EthernetFramesTxIn0.unwrap())),
    api_EthernetFramesTxOut0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_16_tx0_no_input
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_spec_hlr_16_tx0_no_input_guarantee(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    !(api_EthernetFramesTxIn0.is_some()),
    api_EthernetFramesTxOut0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_07_tx1_can_send_valid_arp
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  */
pub fn compute_spec_hlr_07_tx1_can_send_valid_arp_guarantee(
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn1.is_some() & valid_arp(api_EthernetFramesTxIn1.unwrap()),
    api_EthernetFramesTxOut1.is_some() &
      ((api_EthernetFramesTxIn1.unwrap() == api_EthernetFramesTxOut1.unwrap().amessage) &
        valid_output_arp_size(api_EthernetFramesTxOut1.unwrap())))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_12_tx1_can_send_valid_ipv4
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  */
pub fn compute_spec_hlr_12_tx1_can_send_valid_ipv4_guarantee(
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn1.is_some() & valid_ipv4(api_EthernetFramesTxIn1.unwrap()),
    api_EthernetFramesTxOut1.is_some() &
      ((api_EthernetFramesTxIn1.unwrap() == api_EthernetFramesTxOut1.unwrap().amessage) &
        valid_output_ipv4_size(api_EthernetFramesTxIn1.unwrap(), api_EthernetFramesTxOut1.unwrap())))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_14_tx1_disallow
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  */
pub fn compute_spec_hlr_14_tx1_disallow_guarantee(
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn1.is_some() & !(allow_outbound_frame(api_EthernetFramesTxIn1.unwrap())),
    api_EthernetFramesTxOut1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_16_tx1_no_input
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  */
pub fn compute_spec_hlr_16_tx1_no_input_guarantee(
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    !(api_EthernetFramesTxIn1.is_some()),
    api_EthernetFramesTxOut1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_07_tx2_can_send_valid_arp
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  */
pub fn compute_spec_hlr_07_tx2_can_send_valid_arp_guarantee(
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn2.is_some() & valid_arp(api_EthernetFramesTxIn2.unwrap()),
    api_EthernetFramesTxOut2.is_some() &
      ((api_EthernetFramesTxIn2.unwrap() == api_EthernetFramesTxOut2.unwrap().amessage) &
        valid_output_arp_size(api_EthernetFramesTxOut2.unwrap())))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_12_tx2_can_send_valid_ipv4
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  */
pub fn compute_spec_hlr_12_tx2_can_send_valid_ipv4_guarantee(
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn2.is_some() & valid_ipv4(api_EthernetFramesTxIn2.unwrap()),
    api_EthernetFramesTxOut2.is_some() &
      ((api_EthernetFramesTxIn2.unwrap() == api_EthernetFramesTxOut2.unwrap().amessage) &
        valid_output_ipv4_size(api_EthernetFramesTxIn2.unwrap(), api_EthernetFramesTxOut2.unwrap())))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_14_tx2_disallow
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  */
pub fn compute_spec_hlr_14_tx2_disallow_guarantee(
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn2.is_some() & !(allow_outbound_frame(api_EthernetFramesTxIn2.unwrap())),
    api_EthernetFramesTxOut2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_16_tx2_no_input
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  */
pub fn compute_spec_hlr_16_tx2_no_input_guarantee(
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    !(api_EthernetFramesTxIn2.is_some()),
    api_EthernetFramesTxOut2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_07_tx3_can_send_valid_arp
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_spec_hlr_07_tx3_can_send_valid_arp_guarantee(
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn3.is_some() & valid_arp(api_EthernetFramesTxIn3.unwrap()),
    api_EthernetFramesTxOut3.is_some() &
      ((api_EthernetFramesTxIn3.unwrap() == api_EthernetFramesTxOut3.unwrap().amessage) &
        valid_output_arp_size(api_EthernetFramesTxOut3.unwrap())))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_12_tx3_can_send_valid_ipv4
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_spec_hlr_12_tx3_can_send_valid_ipv4_guarantee(
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn3.is_some() & valid_ipv4(api_EthernetFramesTxIn3.unwrap()),
    api_EthernetFramesTxOut3.is_some() &
      ((api_EthernetFramesTxIn3.unwrap() == api_EthernetFramesTxOut3.unwrap().amessage) &
        valid_output_ipv4_size(api_EthernetFramesTxIn3.unwrap(), api_EthernetFramesTxOut3.unwrap())))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_14_tx3_disallow
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_spec_hlr_14_tx3_disallow_guarantee(
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    api_EthernetFramesTxIn3.is_some() & !(allow_outbound_frame(api_EthernetFramesTxIn3.unwrap())),
    api_EthernetFramesTxOut3.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_16_tx3_no_input
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_spec_hlr_16_tx3_no_input_guarantee(
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage>) -> bool
{
  implies!(
    !(api_EthernetFramesTxIn3.is_some()),
    api_EthernetFramesTxOut3.is_none())
}

/** CEP-T-Guar: Top-level guarantee contracts for firewall's compute entrypoint
  *
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage>) -> bool
{
  let r0: bool = compute_spec_hlr_07_tx0_can_send_valid_arp_guarantee(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);
  let r1: bool = compute_spec_hlr_12_tx0_can_send_valid_ipv4_guarantee(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);
  let r2: bool = compute_spec_hlr_14_tx0_disallow_guarantee(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);
  let r3: bool = compute_spec_hlr_16_tx0_no_input_guarantee(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);
  let r4: bool = compute_spec_hlr_07_tx1_can_send_valid_arp_guarantee(api_EthernetFramesTxIn1, api_EthernetFramesTxOut1);
  let r5: bool = compute_spec_hlr_12_tx1_can_send_valid_ipv4_guarantee(api_EthernetFramesTxIn1, api_EthernetFramesTxOut1);
  let r6: bool = compute_spec_hlr_14_tx1_disallow_guarantee(api_EthernetFramesTxIn1, api_EthernetFramesTxOut1);
  let r7: bool = compute_spec_hlr_16_tx1_no_input_guarantee(api_EthernetFramesTxIn1, api_EthernetFramesTxOut1);
  let r8: bool = compute_spec_hlr_07_tx2_can_send_valid_arp_guarantee(api_EthernetFramesTxIn2, api_EthernetFramesTxOut2);
  let r9: bool = compute_spec_hlr_12_tx2_can_send_valid_ipv4_guarantee(api_EthernetFramesTxIn2, api_EthernetFramesTxOut2);
  let r10: bool = compute_spec_hlr_14_tx2_disallow_guarantee(api_EthernetFramesTxIn2, api_EthernetFramesTxOut2);
  let r11: bool = compute_spec_hlr_16_tx2_no_input_guarantee(api_EthernetFramesTxIn2, api_EthernetFramesTxOut2);
  let r12: bool = compute_spec_hlr_07_tx3_can_send_valid_arp_guarantee(api_EthernetFramesTxIn3, api_EthernetFramesTxOut3);
  let r13: bool = compute_spec_hlr_12_tx3_can_send_valid_ipv4_guarantee(api_EthernetFramesTxIn3, api_EthernetFramesTxOut3);
  let r14: bool = compute_spec_hlr_14_tx3_disallow_guarantee(api_EthernetFramesTxIn3, api_EthernetFramesTxOut3);
  let r15: bool = compute_spec_hlr_16_tx3_no_input_guarantee(api_EthernetFramesTxIn3, api_EthernetFramesTxOut3);

  return r0 && r1 && r2 && r3 && r4 && r5 && r6 && r7 && r8 && r9 && r10 && r11 && r12 && r13 && r14 && r15;
}

/** CEP-Post: Compute Entrypoint Post-Condition for firewall
  *
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage>) -> bool
{
  // CEP-Guar: guarantee clauses of firewall's compute entrypoint
  let r0: bool = compute_CEP_T_Guar(api_EthernetFramesTxIn0, api_EthernetFramesTxIn1, api_EthernetFramesTxIn2, api_EthernetFramesTxIn3, api_EthernetFramesTxOut0, api_EthernetFramesTxOut1, api_EthernetFramesTxOut2, api_EthernetFramesTxOut3);

  return r0;
}
